---
layout: post
title: UE Slate урок 1
published: false
---
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.prewiev.png)  
К моему удивлению, на просторах интернета практически нет уроков по слейту, а те что есть объясняют только самые основы. Пришло время это исправить. Я постараюсь написать несколько уроков, в которых затрону основные вопросы и проблемы связанные со слейтом.  
**Сразу замечу, что вы должны иметь хотя бы минимальный опыт работы с блюпринтовыми виджетами, иначе вам будет гораздо сложнее в изучении слейта.**

# SLATE
**Slate** - это фреймворк анрила для создания пользовательского интерфейса. Все что вы видете на экране при запуске анрила, это слейт. Все меню, все кнопки и тд. все работает на слейте.  
Блюпринтовые виджеты тоже работают на слейте, и любой добавленный элемент на этот виджет тоже работает на слейте. Какие отличия у блюпринтового виджета и чистого слейта расскажу дальше.  

# Первый виджет на Slate
Создадим два новых файла SlateWidget.h и SlateWidget.cpp
**SlateWidget.h:**





















# Добавление функции GetCDO
Вернемся к главному вопросу: "Как поменять переменную блюпринта другим блюпринтом?", сейчас нам очень пригодятся знания о существовании **CDO**. 
Можно ли сказать, что когда мы меняем значение переменной блюпринта, мы меняем его **CDO**? Да, конечно, ведь по сути именно это мы и делаем. 
Внезапно наш вопрос меняется: "Как изменить **CDO** блюпринта другим блюпринтом?". К сожалению, в блюпринтах есть возможность только лишь получить **CDO** с помощью функции "**Get Class Defaults**",
но не изменить его. Досадно...  
Однако сделать это в коде очень просто.  

Нам нужно создать **BlueprintFunctionLibrary**, куда мы добавим функцию, которая будет возвращать CDO блюпрнта.  
**MyBlueprintFunctionLibrary.h:**
    
    #pragma once
    
    #include "CoreMinimal.h"
    #include "Kismet/BlueprintFunctionLibrary.h"
    #include "MyBlueprintFunctionLibrary.generated.h"
    
    UCLASS()
    class THIRDPERSONPROJ_API UMyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
    {
    	GENERATED_BODY()
    
        UFUNCTION(BlueprintCallable, Category = "MyBlueprintFunctionLibrary")
        static UObject* GetCDO(UClass* Class)
      {
        return Class->GetDefaultObject();
      }
    	
    };

**GetDefaultObject()** как раз та самая C++ функция, которая возвращает **CDO** блюпринта и позволяет нам с ним делать все, что мы хотим.  

# Изменение CDO блюпринта 
Теперь представим, что у меня в проекте есть два предмета для восстановления здоровья: **BP_Medicine** и **BP_Medicine_2** (унаследованный от **BP_Medicine**),
и у них будет переменная **HealCount**, которая означает количество восстанавливаемого здоровья при подборе (100 у BP_Medicine и 150 у BP_Medicine_2).
Далее главной целью будет сделать инструмент внутри движка, который позволит мне увеличивать значение этой переменной одновременно у обоих предметов на одинаковую величину нажатием одной кнопки.

Теперь возвращаемся к движку. Дальнейшую логику буду писать в **EditorUtilityWidget**, поэтому создаем новый блюпринт этого класса.  
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.1.png)  
О том, что это такое есть отдельная [статья](https://pelogetan.github.io/blutilities-and-editorutilitywidget/)  

Теперь добавляем кнопку и поле для ввода текста:  
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.2.png)  

Переходим в **Event Graph**, добавляем ивент нажатия на кнопку и пишем логику:  
В первую очередь, нам нужно каким-то образом получить класс наших блюпринтов. Есть два пути:  
1 - Создать массив классов и добавить туда нужные нам классы блюпринтов.  
2 - Создать массив строк и добавить туда текстовые ссылки на классы.  
Чтобы получить ссылку на класс, нужно нажать ПКМ на блюпринт и выбрать "**Copy Reference**". Второй способ так же потребует использования функции **LoadBlueprintClass**, чтобы получить класс по ссылке.  
Этот способ очень полезен, если вы храните и настраиваете все значения блюпринтов вне движка, а загружаете их в него.  
Далее буду рассматривать только первый способ.  

Итак, у нас есть массив, в который я добавил классы **BP_Medicine** и **BP_Medicine_2**. По нему нужно пройти циклом, поэтому добаляю функцию **ForEachLoop** и на **LoopBody** вызываю нашу функцию **GetCDO**.
Важно понимать, что **GetCDO** возвращает указатель на **UObject**, поэтому нам нужно сделать каст на нужный нам тип (в нашем случае это **BP_Medicine**). Далее получаем переменную **HealCount** и умножаем её на
содержимое поля ввода ( к сожалению в UE в блюпринтах нельзя сразу получить из FText float, только через чепочку FText->FString->float ) и полученное значение назначаем этой же переменной.
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.3.png)  
В принципе, все готово - можно компилировать и запускать виджет. Для запуска виджета нужно нажать по нему ПКМ и выбрать "**Run Editor Utility Widget**".  
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.4.png)  
Теперь указываем нужное значение (я указал 1.5) и жмем. Проверяем значение **HealCount** в блюпринтах:  
![]({{site.baseurl}}/images/2023-01-20-change-CDO-by-blueprint/2023-01-20-change-CDO-by-blueprint.5.png)  
Значения увеличились ровно в 1.5 раза, мы добились той цели, которую поставили раньше. Этот инструмент позволяет увеличивать значение переменной HealCount у всех классов в массиве нажатием одной кнопки.

# Заключение
Возможность менять значения переменных блюпринтов с помощью других блюпринтов открывает большие возможности по написанию инструментов для упрощения разработки. Все ограничивается только вашей фантазией.

# Полезные ссылки:
[Подробный пост про CDO](https://1danielcoelho.github.io/unreal-engine-basics-base-classes/)  
[Unreal Property System (Reflection)](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)
